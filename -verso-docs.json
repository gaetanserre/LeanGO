{"99":
 "<code>∀ (n : ℕ) (data : prod_iter_image ↑α ℝ n), ℙ (potential_max data κ) ≠ 0</code>",
 "98":
 "<code>Top.top.{u_1} {α : Type u_1} [self : Top α] : α</code><span class=\"sep\"></span><code class=\"docstring\">The top (`⊤`, `\\top`) element \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `⊤` in identifiers is `top`.</code>",
 "97":
 "<code>ED (d : ℕ) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Euclidean space of dimension `d`.\nUsed as the domain for LIPO optimization problems. </code>",
 "96":
 "<code>NNReal : Type</code><span class=\"sep\"></span><code class=\"docstring\">Nonnegative real numbers, denoted as `ℝ≥0` within the NNReal namespace </code>",
 "95": "<code>Measure ↑α</code>",
 "94":
 "<code>LIPO {d : ℕ} {κ : ℝ≥0} {α : Set (ℝᵈ d)} (mes_α : MeasurableSet α) (mα₀ : ℙ α ≠ 0) (mα₁ : ℙ α ≠ ⊤)\n  (h : ∀ (n : ℕ) (data : prod_iter_image ↑α ℝ n), ℙ (potential_max data κ) ≠ 0) : Algorithm ↑α ℝ</code><span class=\"sep\"></span><code class=\"docstring\">The LIPO (LIPschitz Optimization) algorithm for global optimization.\nThis algorithm optimizes an unknown function assuming only that it has a finite Lipschitz\nconstant `κ`. It starts with a uniform initial distribution and iteratively samples from\nthe set of potential maximizers, ensuring consistency and convergence to the global optimum\n(Malherbe et al., 2017). </code>",
 "93": "<code>ℙ α ≠ ⊤</code>",
 "92": "<code>ENNReal</code>",
 "91": "<code>ℙ α ≠ 0</code>",
 "90": "<code>MeasurableSet α</code>",
 "9": "<code>Measure α</code>",
 "89": "<code>Set (ℝᵈ d)</code>",
 "88": "<code>ℝ≥0</code>",
 "87":
 "<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {α : Type u}      -- implicit\n    (a : α)           -- explicit\n    [instBEq : BEq α] -- instance implicit, named\n    [Hashable α]      -- instance implicit, anonymous\n\n  def isEqual (b : α) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : α} := a == b ↔ b == a\n\n  #check eqComm\n  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src × String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {α : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString α]  -- available in the proof as `α` is included\n  (a : α)       -- available in the proof as mentioned in the header\n  {β : Type}    -- not available in the proof\n  [ToString β]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString α]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>",
 "86": "<code>prod_iter_image α β x✝¹</code>",
 "85":
 "<code>ProbabilityTheory.IsMarkovKernel.mk.{u_1, u_2} {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α}\n  {mβ : MeasurableSpace β} {κ : Kernel α β} (isProbabilityMeasure : ∀ (a : α), IsProbabilityMeasure (κ a)) :\n  IsMarkovKernel κ</code>",
 "84":
 "<code>∀ (x : ℕ), IsMarkovKernel (Kernel.const (prod_iter_image α β x) (uniform univ))</code>",
 "83":
 "<code>ProbabilityTheory.Kernel.const.{u_4, u_5} (α : Type u_4) {β : Type u_5} [MeasurableSpace α] {x✝ : MeasurableSpace β}\n  (μβ : Measure β) : Kernel α β</code><span class=\"sep\"></span><code class=\"docstring\">Constant kernel, which always returns the same measure. </code>",
 "82": "<code>(x : ℕ) → Kernel (prod_iter_image α β x) α</code>",
 "81":
 "<code>NeZero.ne.{u_1} {R : Type u_1} [Zero R] (n : R) [h : NeZero n] : n ≠ 0</code>",
 "80":
 "<code>Ne.{u} {α : Sort u} (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.</code>",
 "8":
 "<code>MeasureTheory.IsProbabilityMeasure.{u_1} {α : Type u_1} {m0 : MeasurableSpace α} (μ : Measure α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A measure `μ` is called a probability measure if `μ univ = 1`. </code>",
 "79":
 "<code>NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A type-class version of `n ≠ 0`.  </code>",
 "78": "<code>NeZero ℙ</code>",
 "77":
 "<code>MeasureTheory.MeasureSpace.volume.{u_6} {α : Type u_6} [self : MeasureSpace α] : Measure α</code><span class=\"sep\"></span><code class=\"docstring\">`volume` is the canonical measure on `α`. </code>",
 "76":
 "<code>MeasureTheory.IsFiniteMeasure.{u_1} {α : Type u_1} {m0 : MeasurableSpace α} (μ : Measure α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A measure `μ` is called finite if `μ univ &lt; ∞`. </code>",
 "75": "<code>IsFiniteMeasure ℙ</code>",
 "74":
 "<code>MeasureTheory.MeasureSpace.{u_6} (α : Type u_6) : Type u_6</code><span class=\"sep\"></span><code class=\"docstring\">A measure space is a measurable space equipped with a\nmeasure, referred to as `volume`. </code>",
 "73": "<code>MeasureSpace α</code>",
 "72":
 "<code>uniform_is_prob_measure.{u_1} {α : Type u_1} [MeasureSpace α] [IsFiniteMeasure ℙ] {s : Set α} (hs : ℙ s ≠ 0) :\n  IsProbabilityMeasure (uniform s)</code>",
 "71": "<code>IsProbabilityMeasure (uniform univ)</code>",
 "70":
 "<code>uniform.{u_1} {α : Type u_1} [MeasureSpace α] (s : Set α) : Measure α</code>",
 "7":
 "<code>Algorithm.prob_measure.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (self : Algorithm α β) : IsProbabilityMeasure self.ν</code>",
 "69": "<code>Measure α</code>",
 "68":
 "<code>PRS.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasureSpace α] [IsFiniteMeasure ℙ] [NeZero ℙ] [MeasurableSpace β] :\n  Algorithm α β</code><span class=\"sep\"></span><code class=\"docstring\">The Pure Random Search (PRS) algorithm for global optimization.\nThis baseline algorithm samples uniformly from the input space at each iteration,\nindependently of past observations. It serves as a reference benchmark for comparing\nmore sophisticated optimization strategies. </code>",
 "67":
 "<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "66": "<code>↥(Finset.Iic n)</code>",
 "65":
 "<code>Finset.Iic.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrderBot α] (b : α) : Finset α</code><span class=\"sep\"></span><code class=\"docstring\">The finset $(-∞, b]$ of elements `x` such that `x ≤ b`. Basically `Set.Iic b` as a finset. </code>",
 "64":
 "<code>Set.pi.{u_1, u_2} {ι : Type u_1} {α : ι → Type u_2} (s : Set ι) (t : (i : ι) → Set (α i)) : Set ((i : ι) → α i)</code><span class=\"sep\"></span><code class=\"docstring\">Given an index set `ι` and a family of sets `t : Π i, Set (α i)`, `pi s t`\nis the set of dependent functions `f : Πa, π a` such that `f i` belongs to `t i`\nwhenever `i ∈ s`. </code>",
 "63":
 "<code>Set.univ.{u} {α : Type u} : Set α</code><span class=\"sep\"></span><code class=\"docstring\">The universal set on a type `α` is the set containing all elements of `α`.\n\nThis is conceptually the \"same as\" `α` (in set theory, it is actually the same), but type theory\nmakes the distinction that `α` is a type while `Set.univ` is a term of type `Set α`. `Set.univ` can\nitself be coerced to a type `↥Set.univ` which is in bijection with (but distinct from) `α`. </code>",
 "62":
 "<code>MeasureTheory.Measure.restrict.{u_2} {α : Type u_2} {_m0 : MeasurableSpace α} (μ : Measure α) (s : Set α) : Measure α</code><span class=\"sep\"></span><code class=\"docstring\">Restrict a measure `μ` to a set `s`. </code>",
 "61":
 "<code>Set.EqOn.{u, v} {α : Type u} {β : Type v} (f₁ f₂ : α → β) (s : Set α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Two functions `f₁ f₂ : α → β` are equal on `s` if `f₁ x = f₂ x` for all `x ∈ s`. </code>",
 "60": "<code>EqOn f g s</code>",
 "6":
 "<code>MeasureTheory.Measure.{u_6} (α : Type u_6) [MeasurableSpace α] : Type u_6</code><span class=\"sep\"></span><code class=\"docstring\">A measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the additional assumption that the outer measure is the canonical\nextension of the restricted measure.\n\nThe measure of a set `s`, denoted `μ s`, is an extended nonnegative real. The real-valued version\nis written `μ.real s`.\n</code>",
 "59": "<code>Set α</code>",
 "58": "<code>Measurable g</code>",
 "57":
 "<code>Algorithm.eq_restrict.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (A : Algorithm α β) {f g : α → β} (hf : Measurable f) (hg : Measurable g) {s : Set α} (hs : MeasurableSet s)\n  (h : EqOn f g s) (n : ℕ) :\n  (A.fin_measure hf).restrict (univ.pi fun x =&gt; s) = (A.fin_measure hg).restrict (univ.pi fun x =&gt; s)</code><span class=\"sep\"></span><code class=\"docstring\">If two measurable functions `f` and `g` agree on a measurable set `s`, then the algorithm's\ninduced measures at iteration `n` are identical when restricted to trajectories that stay\nwithin `s`. This establishes that the algorithm depends only on the objective function values\non the relevant domain. </code>",
 "56":
 "<code>Membership.mem.{u, v} {α : outParam (Type u)} {γ : Type v} [self : Membership α γ] : γ → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.</code>",
 "55":
 "<code>setOf.{u} {α : Type u} (p : α → Prop) : Set α</code><span class=\"sep\"></span><code class=\"docstring\">Turn a predicate `p : α → Prop` into a set, also written as `{x | p x}` </code>",
 "54":
 "<code>HasSubset.Subset.{u} {α : Type u} [self : HasSubset α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Subset relation: `a ⊆ b`  \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `⊆` in identifiers is `subset`.</code>",
 "53":
 "<code>LE.le.{u} {α : Type u} [self : LE α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "52":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "51":
 "<code>Tuple.subTuple.{u_1} {α : Type u_1} {n m : ℕ} (hnm : n ≤ m) (u : iter α m) : iter α n</code><span class=\"sep\"></span><code class=\"docstring\">Given `n ≤ m`, this is the restriction of a function `u : iter α m`\nto a function `iter α n`. </code>",
 "50": "<code>iter α m</code>",
 "5":
 "<code>Algorithm.ν.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (self : Algorithm α β) :\n  Measure α</code>",
 "49": "<code>e ⊆ {u | subTuple hmn u ∈ s}</code>",
 "48": "<code>n ≤ m</code>",
 "47": "<code>MeasurableSet e</code>",
 "46": "<code>Set (iter α m)</code>",
 "45":
 "<code>MeasurableSet.{u_1} {α : Type u_1} [MeasurableSpace α] (s : Set α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`MeasurableSet s` means that `s` is measurable (in the ambient measure space on `α`) </code>",
 "44": "<code>MeasurableSet s</code>",
 "43":
 "<code>Set.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A set is a collection of elements of some type `α`.\n\nAlthough `Set` is defined as `α → Prop`, this is an implementation detail which should not be\nrelied on. Instead, `setOf` and membership of a set (`∈`) should be used to convert between sets\nand predicates.\n</code>",
 "42": "<code>Set (iter α n)</code>",
 "41":
 "<code>Algorithm.fin_measure_mono.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (A : Algorithm α β) {n m : ℕ} {s : Set (iter α n)} (hs : MeasurableSet s) {e : Set (iter α m)} (he : MeasurableSet e)\n  (hmn : n ≤ m) (hse : e ⊆ {u | subTuple hmn u ∈ s}) {f : α → β} (hf : Measurable f) :\n  (A.fin_measure hf) e ≤ (A.fin_measure hf) s</code><span class=\"sep\"></span><code class=\"docstring\">Monotonicity of the algorithm's induced measures under trajectory extension.\n\nLet `s : Set iter α n` be a measurable set of point sequences of length `n`,\nand `e : Set iter α m` for some `m ≥ n` a set of longer trajectories such that\nevery `u ∈ e` satisfies `subTuple hmn u ∈ s`.\n\nThen the measure assigned to `e` by the algorithm at step `m` is less than or equal to\nthe measure assigned to `s` at step `n`.\n\nThis expresses that the family of measures is projectively consistent:\nthe measure on longer trajectories contracts to the measure on shorter ones via truncation.\n\nFormally: if `e ⊆ {u | subTuple hmn u ∈ s}`, then `A.fin_measure hf m e ≤ A.fin_measure hf n s`. </code>",
 "40":
 "<code>Preorder.frestrictLe.{u_1, u_2} {α : Type u_1} [Preorder α] {π : α → Type u_2} [LocallyFiniteOrderBot α] (a : α)\n  (f : (i : α) → π i) (i : ↥(Finset.Iic a)) : π ↑i</code><span class=\"sep\"></span><code class=\"docstring\">Restrict domain of a function `f` indexed by `α` to elements `≤ a`, seen as a finite set. </code>",
 "4":
 "<code>MeasurableSpace.{u_7} (α : Type u_7) : Type u_7</code><span class=\"sep\"></span><code class=\"docstring\">A measurable space is a space equipped with a σ-algebra. </code>",
 "39":
 "<code>MeasureTheory.Measure.map.{u_4, u_5} {α : Type u_4} {β : Type u_5} [MeasurableSpace α] [MeasurableSpace β] (f : α → β)\n  (μ : Measure α) : Measure β</code><span class=\"sep\"></span><code class=\"docstring\">The pushforward of a measure. It is defined to be `0` if `f` is not an almost everywhere\nmeasurable function. </code>",
 "38":
 "<code>Algorithm.fin_measure.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (A : Algorithm α β) {f : α → β} (hf : Measurable f) {n : ℕ} : Measure (iter α n)</code><span class=\"sep\"></span><code class=\"docstring\">The measure on finite sequences of iterations, defined by pushing forward `measure`\nalong the measurable function `frestrictLe n : (ℕ → α) → iter α n` that restricts\nthe infinite sequence to its first `n` elements. This is the measure that will be used\nthroughout the formalization. </code>",
 "37":
 "<code class=\"docstring\">`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n</code>",
 "36":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "35":
 "<code>Measurable.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (f : α → β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f` between measurable spaces is measurable if the preimage of every\nmeasurable set is measurable. </code>",
 "34": "<code>MeasurableSpace β</code>",
 "33": "<code>MeasurableSpace α</code>",
 "32":
 "<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>",
 "31":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "30":
 "<code>ProbabilityTheory.Kernel.avg.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (κ : Kernel α β) (μ : Measure α) : Measure β</code><span class=\"sep\"></span><code class=\"docstring\">The average of a kernel `κ` by a measure `μ`. Defined as `s↦ ∫⁻ a, κ a s ∂μ` </code>",
 "3":
 "<code class=\"docstring\">The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`&gt; 0` for each variable in the sequence. </code>",
 "29":
 "<code>Algorithm.measure.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] {f : α → β}\n  (hf : Measurable f) (A : Algorithm α β) : Measure (ℕ → α)</code><span class=\"sep\"></span><code class=\"docstring\">The measure on infinite sequences of iterations. It is constructed by first obtaining\na kernel from `iter α 0` to `ℕ → α` via the Ionescu-Tulcea theorem, and then averaging the kernel\nover the initial measure `A.ν_mequiv`. This gives a measure on the space of infinite sequences\nof points in `α`, which can be used to analyze the convergence properties of the algorithm. </code>",
 "28":
 "<code>MeasurableEquiv.funUnique.{u_8, u_9} (α : Type u_8) (β : Type u_9) [Unique α] [MeasurableSpace β] : (α → β) ≃ᵐ β</code><span class=\"sep\"></span><code class=\"docstring\">If `α` has a unique term, then the type of function `α → β` is measurably equivalent to `β`. </code>",
 "27":
 "<code>MeasureTheory.Measure.comap.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (f : α → β)\n  (μ : Measure β) : Measure α</code><span class=\"sep\"></span><code class=\"docstring\">Pullback of a `Measure`. If `f` sends each measurable set to a null-measurable set,\nthen for each measurable set `s` we have `comap f μ s = μ (f '' s)`.\n\nNote that if `f` is not injective, this definition assigns `Set.univ` measure zero. </code>",
 "26":
 "<code>Algorithm.ν_mequiv.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (A : Algorithm α β) : Measure (iter α 0)</code><span class=\"sep\"></span><code class=\"docstring\">The measure `ν` that has been pulled back along the measurable equivalence\n`MeasurableEquiv.funUnique (iter α 0) α` to change the type of `ν` from\n`Measure α` to `Measure (iter α 0)`. </code>",
 "25": "<code>Measurable f</code>",
 "24":
 "<code>Tuple.measurable_prod_eval.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β] (n : ℕ)\n  {f : α → β} (hf : Measurable f) : Measurable (prod_eval n f)</code><span class=\"sep\"></span><code class=\"docstring\">For any measurable function `f : α → β`, the function `prod_eval n f` is measurable. </code>",
 "23": "<code>α → β</code>",
 "22":
 "<code>Tuple.prod_eval.{u_1, u_2} {α : Type u_1} {β : Type u_2} (n : ℕ) (f : α → β) (u : iter α n) :\n  iter α n × (↥(Finset.Iic n) → β)</code><span class=\"sep\"></span><code class=\"docstring\">Given `n`, a function `f : α → β` and a function `u : iter α n`,\nthis is the pair `(u, f ∘ u)`, where `f ∘ u` is the function\nfrom `Fin (n + 1)` to `β` that applies `f` to the values of `u`. </code>",
 "21":
 "<code>ProbabilityTheory.Kernel.comap.{u_1, u_2, u_4} {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α}\n  {mβ : MeasurableSpace β} {γ : Type u_4} {mγ : MeasurableSpace γ} (κ : Kernel α β) (g : γ → α) (hg : Measurable g) :\n  Kernel γ β</code><span class=\"sep\"></span><code class=\"docstring\">Pullback of a kernel, such that for each set s `comap κ g hg c s = κ (g c) s`.\nWe include measurability in the assumptions instead of using junk values\nto make sure that typeclass inference can infer that the `comap` of a Markov kernel\nis again a Markov kernel. </code>",
 "20": "<code>Algorithm α β</code>",
 "2": "<code>Type u_2</code>",
 "19":
 "<code>iter.{u_1} (α : Type u_1) (n : ℕ) : Type u_1</code><span class=\"sep\"></span><code class=\"docstring\">`iter α n` is the type of finite sequences of elements in `α` of length `n + 1`.\n\nIt represents the history of `n + 1` steps in an iterative process,\nwith entries indexed by `Fin (n + 1)` (i.e., from `0` to `n`).\n\nUsed in the context of stochastic iterative algorithms to store past evaluations or points. </code>",
 "18":
 "<code>Algorithm.iter_comap.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (A : Algorithm α β) {f : α → β} (hf : Measurable f) (n : ℕ) : Kernel (iter α n) α</code><span class=\"sep\"></span><code class=\"docstring\">Given a measurable function `f : α → β` representing the evaluation (e.g., objective function),\nthis constructs a new kernel that maps a history of points (in `iter α n`)\nto a probability distribution over the next point in `α`.\n\nThe original algorithm `A` provides a transition kernel `A.kernel_iter n` that depends on\nboth the previously proposed points and their corresponding evaluations.\nHowever, in practice, the algorithm itself only generates the sequence of points,\nand the evaluations are computed externally by applying `f` to each point.\n\nThe function `prod_eval n f` deterministically reconstructs the full history\n(points and their evaluations) from the point sequence alone, using `f` and\nthe `comap` pulls back the original kernel along this map,\nresulting in a kernel that operates directly on the sequence of points. </code>",
 "17":
 "<code>ProbabilityTheory.Kernel.traj.{u_1} {X : ℕ → Type u_1} [(n : ℕ) → MeasurableSpace (X n)]\n  (κ : (n : ℕ) → Kernel ((i : ↥(Finset.Iic n)) → X ↑i) (X (n + 1))) [∀ (n : ℕ), IsMarkovKernel (κ n)] (a : ℕ) :\n  Kernel ((i : ↥(Finset.Iic a)) → X ↑i) ((n : ℕ) → X n)</code><span class=\"sep\"></span><code class=\"docstring\">*Ionescu-Tulcea Theorem* : Given a family of kernels `κ n` taking variables in `Iic n` with\nvalue in `X (n + 1)`, the kernel `traj κ a` takes a variable `x` depending on the\nvariables `i ≤ a` and associates to it a kernel on trajectories depending on all variables,\nwhere the entries with index `≤ a` are those of `x`, and then one follows iteratively the\nkernels `κ a`, then `κ (a + 1)`, and so on.\n\nThe fact that such a kernel exists on infinite trajectories is not obvious, and is the content of\nthe Ionescu-Tulcea theorem. </code>",
 "16": "<code>(n : ℕ) → Kernel (prod_iter_image α β n) α</code>",
 "15":
 "<code>ProbabilityTheory.IsMarkovKernel.{u_1, u_2} {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α}\n  {mβ : MeasurableSpace β} (κ : Kernel α β) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A kernel is a Markov kernel if every measure in its image is a probability measure. </code>",
 "14":
 "<code>Algorithm.markov_kernel.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (self : Algorithm α β) (n : ℕ) : IsMarkovKernel (self.kernel_iter n)</code>",
 "13":
 "<code>prod_iter_image.{u_1, u_2} (α : Type u_1) (β : Type u_2) (n : ℕ) : Type (max u_1 u_2)</code><span class=\"sep\"></span><code class=\"docstring\">`prod_iter_image α β n` is the input space of the algorithm at iteration `n`.\n\nIt consists of:\n- a sequence of `n + 1` past points in `α`,\n- and their corresponding evaluations in `β`.\n\nThis pair encodes the full information available up to iteration `n`. </code>",
 "12":
 "<code>ProbabilityTheory.Kernel.{u_1, u_2} (α : Type u_1) (β : Type u_2) [MeasurableSpace α] [MeasurableSpace β] :\n  Type (max u_1 u_2)</code><span class=\"sep\"></span><code class=\"docstring\">A kernel from a measurable space `α` to another measurable space `β` is a measurable function\n`κ : α → Measure β`. The measurable space structure on `MeasureTheory.Measure β` is given by\n`MeasureTheory.Measure.instMeasurableSpace`. A map `κ : α → MeasureTheory.Measure β` is measurable\niff `∀ s : Set β, MeasurableSet s → Measurable (fun a ↦ κ a s)`. </code>",
 "112":
 "<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>",
 "111":
 "<code>∀ (n : ℕ), IsMarkovKernel (potential_max_kernel mes_α mα₁ κ)</code>",
 "110":
 "<code>LIPO.potential_max_kernel {d : ℕ} {α : Set (ℝᵈ d)} (mes_α : MeasurableSet α) (mα₁ : ℙ α ≠ ⊤) {n : ℕ} (κ : ℝ≥0) :\n  Kernel (prod_iter_image ↑α ℝ n) ↑α</code><span class=\"sep\"></span><code class=\"docstring\">Markov kernel that samples uniformly from the set of potential maximizers.\nThis kernel forms the core sampling strategy of LIPO: at each iteration, given the observed\ndata, it samples the next query point uniformly from `potential_max`. </code>",
 "11": "<code>ℕ</code>",
 "109": "<code>(x : ℕ) → Kernel (prod_iter_image ↑α ℝ x) ↑α</code>",
 "108":
 "<code>MeasurableSet.nullMeasurableSet.{u_2} {α : Type u_2} {m0 : MeasurableSpace α} {μ : Measure α} {s : Set α}\n  (h : MeasurableSet s) : NullMeasurableSet s μ</code>",
 "107":
 "<code>MeasureTheory.Measure.Subtype.volume_univ.{u_4} {δ : Type u_4} {u : Set δ} [MeasureSpace δ]\n  (hu : NullMeasurableSet u ℙ) : ℙ univ = ℙ u</code>",
 "106":
 "<code class=\"docstring\">`rwa` is short-hand for `rw; assumption`. </code>",
 "105":
 "<code class=\"docstring\">`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n</code>",
 "104":
 "<code>LIPO.i₁ {d : ℕ} {α : Set (ℝᵈ d)} (mes_α : MeasurableSet α) (mα₁ : ℙ α ≠ ⊤) : IsFiniteMeasure ℙ</code>",
 "103":
 "<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition's value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>",
 "102":
 "<code>LIPO.potential_max {d : ℕ} {α : Set (ℝᵈ d)} {n : ℕ} (data : prod_iter_image ↑α ℝ n) (κ : ℝ≥0) : Set ↑α</code><span class=\"sep\"></span><code class=\"docstring\">The set of potential maximizers for the LIPO algorithm.\nGiven observed data points and function values, this set contains all points `x` where\nthe maximum observed value is at most the minimum Lipschitz upper bound across all observations.\nThe upper bound at `x` from observation `i` is `f(xᵢ) + κ·d(xᵢ, x)`, where `κ` is the\nLipschitz constant. </code>",
 "101":
 "<code>Real : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. </code>",
 "100": "<code>prod_iter_image ↑α ℝ n</code>",
 "10":
 "<code>Algorithm.kernel_iter.{u_1, u_2} {α : Type u_1} {β : Type u_2} [MeasurableSpace α] [MeasurableSpace β]\n  (self : Algorithm α β) (n : ℕ) : Kernel (prod_iter_image α β n) α</code>",
 "1": "<code>Type u_1</code>",
 "0":
 "<code>Algorithm.{u_1, u_2} (α : Type u_1) (β : Type u_2) [MeasurableSpace α] [MeasurableSpace β] : Type (max u_1 u_2)</code><span class=\"sep\"></span><code class=\"docstring\">`Algorithm α β` represents a general iterative stochastic optimization algorithm.\n\nIt models a sequence of updates where:\n- `α` is the search space (e.g., parameters, candidate solutions),\n- `β` is the evaluation space (e.g., objective values, feedback),\n- `ν` is the initial probability measure over `α` (the starting distribution of candidates),\n- `kernel_iter n` is a Markov kernel that outputs a new candidate in `α`\n  given the history of the first `n` points and their evaluations,\n  i.e., from the space `prod_iter_image α β n` = (`α × β`)ⁿ,\n- `markov_kernel n` asserts that each such `kernel_iter n` is a valid Markov kernel.\n\nIt allows formal reasoning over joint distributions of evaluated points and convergence\nproperties. </code>"}